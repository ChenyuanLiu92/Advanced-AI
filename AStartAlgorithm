# Created by David Liu.
# 2024.4.10 19:32

# import some packages.
import heapq
import time

# Design of the heuristic function.
# Strategy 1: Number of the figures, difference counts of the states and goal_states.
def h1_method(states, goal_states):
    # Initialize the graph to a 3x3 matrix.
    different_states = 0
    for i in range(3) :
        for j in range(3):
            if (states[i][j] != goal_states[i][j] and states != 0):
               different_states += 1
    return different_states

# Strategy 2: Manhattan distance, the number of steps to move figure to the goal location directly.

# This small function is used to find target figure's location in the goal states.

def get_target_num(target, goal_states):
    for i in range(3):
        for j in range(3):
            if (goal_states[i][j] == target):
             return i, j
    return -1, -1

def h2_method(states, goal_states):
    Manhattan_distance = 0
    for i in range(3) :
        for j in range(3):
            if (states[i][j] == 0):
                continue
            if (states[i][j] == goal_states[i][j]):
                continue
            x, y = get_target_num(states[i][j], goal_states)
            Manhattan_distance += abs(i - x) + abs(j - y)
    return Manhattan_distance

# Design of A* algorithm.
def A_star_algorithm(start_states, goal_states, h):
    '''
    Parameters explanation:
    start_states: initial state in 3x3 matrix.
    goal_states: goal state in 3x3 matrix.
    h: heuristic algorithm
    '''
    start_times = time.time()
    open_list = [(h(start_states, goal_states), start_states)] # Stores the priority queue of the node to be expanded.
    closed_set  = set() # Stores the expanded node.
    where_come_from = {} # Stores the father node of a node.
    number_of_expanded_nodes = 0 # Stores the number of expanded nodes.

    while open_list:
        # Popping the node which has highest priority.
        _, current_states = heapq.heappop(open_list)
        number_of_expanded_nodes += 1

        # Now we get the goal state!
        if (current_states == goal_states):
            # Tracing back.
            path = [current_states]
            while (tuple(map(tuple, current_states)) in where_come_from):
                current_states = where_come_from[tuple(map(tuple, current_states))]
                path.append(current_states)

                end_times = time.time()
                return number_of_expanded_nodes, end_times- start_times, path[::-1]

        closed_set.add(tuple(map(tuple, current_states))) # put the current node state in expanded nodes set.
        zero_i, zero_j = get_target_num(0, current_states) # Find the space location.

        moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Arround cells.
        for di, dj in moves:
            new_i, new_j = zero_i + di, zero_j + dj # Moved figure.
            if (0 <= new_i <3 and 0 <= new_j <3):
                new_states = [row[:] for row in current_states] # Copy current state.
                new_states[zero_i][zero_j], new_states[new_i][new_j] = current_states[new_i][new_j], current_states[zero_i][zero_j] # Moving the blank cell.

                if (tuple(map(tuple, new_states)) in closed_set):
                    continue

                new_cost = len(where_come_from) + 1 +h(new_states, goal_states)
                heapq.heappush(open_list, (new_cost, new_states))
                where_come_from[tuple(map(tuple, new_states))] = tuple(map(tuple, current_states))

    return number_of_expanded_nodes, 0, None


# This part for testing.
start_states = [
    [2, 8, 3],
    [1, 6, 4],
    [7, 0, 5]
]

goal_states = [
    [1, 2, 3],
    [8, 0, 4],
    [7, 6, 5]
]

number_of_nodes_using_h1, times_using_h1, path_using_h1 = A_star_algorithm(start_states, goal_states, h1_method)
number_pf_nodes_using_h2, times_using_h2, path_using_h2 = A_star_algorithm(start_states, goal_states, h2_method)

if path_using_h1:
    print("We expanded {} nodes and consumed {}s when using h1 heuristic functions".format(number_of_nodes_using_h1, times_using_h1))
else:
    print("This states have no feasible solution.")

if path_using_h2:
    print("We expanded {} nodes and consumed {}s when using h1 heuristic functions".format(number_pf_nodes_using_h2, times_using_h2))
else:
    print("This states have no feasible solution.")



